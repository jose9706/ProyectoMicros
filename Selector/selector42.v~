

module selector4(output wire [4*4-1:0] temp,
                 input [31:0] DATA_A,
                 input [31:0] DATA_B,
                 input [11:0] sel_A,
                 input [11:0] sel_B,
                 input [3:0] SEL,
                 input RESET_L,
                 input CLK);
                 
    wire [3:0] NIBBLE_OUT [3:0];

    generate
        genvar k;
        for(k = 0; k<4; k = k +1) begin: outs
            assign temp[4*k+3:4*k] = NIBBLE_OUT[k];
        end
    endgenerate


    generate
        genvar i;
        for(i = 0; i <= 3; i = i + 1)
        begin: selectores
            selector seli(DATA_A[31:0],
                     DATA_B[31:0], 
                     sel_A[i*3+:3],
                     sel_B[i*3+:3],
                     SEL[i],
                     RESET_L,
                     CLK,
                     NIBBLE_OUT[i][3:0]);

        end
    endgenerate


endmodule


module selector(  
        input [31:0] dataA,
        input [31:0] dataB,
        input [2:0] selA, 
        input [2:0] selB,
        input sel, 
        input reset_L, 
        input clk,
        output reg [3:0] nibbleOut
); 

//salida de cada una de las entradas
reg [3:0] nibbleA;
reg [3:0] nibbleB; 

//señales temporales 
reg [3:0] tempA;
reg [3:0] tempB;
reg [3:0] tempOut; 


always @(posedge clk)begin
    if(~reset_L) begin 
    nibbleOut<=0; 
    nibbleA<=0; 
    nibbleB<=0;
    end else begin 
    nibbleA<=tempA; 
    nibbleB<=tempB ;
    nibbleOut<=tempOut; 
    end 
end



//Icarus no aguanta esos assign no se por qué
/*
assign tempA = dataA[selA[2:0]*4 +: 4];
assign tempB = dataB[selB[2:0]*4 +: 4];
assign tempOut=sel?nibbleA:nibbleB; 
*/

always @(*) begin 
    tempA = dataA[selA[2:0]*4 +: 4];
    tempB = dataB[selB[2:0]*4 +: 4];
    tempOut=sel?tempB:tempA; //0 agarra tempA y en 1 agarra tempB 
end



endmodule 


