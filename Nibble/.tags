!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CC	makefile	/^CC := iverilog$/;"	m
CC_RUN	makefile	/^CC_RUN := vvp$/;"	m
CC_SYNTH	makefile	/^CC_SYNTH := yosys$/;"	m
CLK	checker.v	/^	input 			CLK,				\/\/ señal de clock del modulo	$/;"	p
CLK	nibble_top.v	/^	input 				CLK,				\/\/ entrada del reloj que controla los modulos$/;"	p
CLK	nibble_top_synth.v	/^  input CLK;$/;"	p
CLK	tb.v	/^	wire		CLK;			\/\/ From test01 of tester.v$/;"	n
DATA_A	nibble_top.v	/^	input [31:0]		DATA_A,				\/\/ Dato A de 32bits$/;"	p
DATA_A	nibble_top_synth.v	/^  input [31:0] DATA_A;$/;"	p
DATA_A	tb.v	/^	wire [31:0]	DATA_A;			\/\/ From test01 of tester.v$/;"	n
DATA_B	nibble_top_synth.v	/^  input [31:0] DATA_B;$/;"	p
DATA_B	tb.v	/^	wire [31:0]	DATA_B;			\/\/ From test01 of tester.v$/;"	n
DATA_OUT	nibble_top_synth.v	/^  output [3:0] DATA_OUT;$/;"	p
DATA_OUT_c	checker.v	/^	input [3:0]		DATA_OUT_c,			\/\/ entrada de datos generada por del modulo conductual$/;"	p
DATA_OUT_c	tb.v	/^	wire [3:0]	DATA_OUT_c;		\/\/ From nibble_cond of nibble_top.v, ...$/;"	n
DATA_OUT_c	tester.v	/^	input [3:0]					DATA_OUT_c,		\/\/ monitor de salida del nibble mayor conductual$/;"	p
DATA_OUT_e	tb.v	/^	wire [3:0]	DATA_OUT_e;		\/\/ From nibble_cond of nibble_top.v, ...$/;"	n
LIB	makefile	/^export LIB := ..\/libs\/osu018_stdcells.lib$/;"	m
NEW_TOP_MODULE	makefile	/^NEW_TOP_MODULE = nibble_top_synth$/;"	m
NEW_VLOG_FILE_NAME	makefile	/^NEW_VLOG_FILE_NAME = nibble_top_synth.v$/;"	m
NIBBLES	nibble_top.v	/^	wire [15:0]	NIBBLES;		\/\/ From logica_seleccion of selector4.v$/;"	n
NIBBLE_MAYOR	nibble_top.v	/^	wire [3:0]	NIBBLE_MAYOR;		\/\/ From nibble_mayor of nibble_mayor_4in.v$/;"	n
OUTPUT_SIM	makefile	/^OUTPUT_SIM := nibble_top.out$/;"	m
OUTPUT_SYNTH	makefile	/^export OUTPUT_SYNTH = nibble_top_synth.v$/;"	m
RESET_L	nibble_top_synth.v	/^  input RESET_L;$/;"	p
RESET_L	tb.v	/^	wire		RESET_L;		\/\/ From test01 of tester.v$/;"	n
SEL_A	nibble_top.v	/^	input [11:0]		SEL_A,				\/\/ array de selectores del DATA_A$/;"	p
SEL_A	nibble_top_synth.v	/^  input [11:0] SEL_A;$/;"	p
SEL_A	tb.v	/^	wire [11:0]	SEL_A;			\/\/ From test01 of tester.v$/;"	n
SEL_AB	nibble_top.v	/^	input [3:0]			SEL_AB				\/\/ array de selectores para seleccion del DATO_A | DATO_B$/;"	p
SEL_AB	nibble_top_synth.v	/^  input [3:0] SEL_AB;$/;"	p
SEL_AB	tb.v	/^	wire [3:0]	SEL_AB;			\/\/ From test01 of tester.v$/;"	n
SEL_B	nibble_top_synth.v	/^  input [11:0] SEL_B;$/;"	p
SEL_B	tb.v	/^	wire [11:0]	SEL_B;			\/\/ From test01 of tester.v$/;"	n
SRC	makefile	/^SRC = yosys.tcl$/;"	m
TARGET_TOP	makefile	/^TARGET_TOP := nibble_top.v$/;"	m
TARGET_VIS	makefile	/^TARGET_VIS := config.gtkw$/;"	m
TOP_MODULE	makefile	/^export TOP_MODULE := nibble_top$/;"	m
VISUAL	makefile	/^VISUAL := gtkwave$/;"	m
VLOG_FILE_NAME	makefile	/^export VLOG_FILE_NAME := nibble_top.v$/;"	m
check_data_out	tester.v	/^	wire check_data_out;		\/\/ salida del modulo checker$/;"	n
checker	checker.v	/^module checker($/;"	m
input	checker.v	/^	input 			RESET_L,			\/\/ señal de reset_L del modulo$/;"	p
input	checker.v	/^	input [3:0]		DATA_OUT_e			\/\/ entrada de datos generada por el modulo estructural$/;"	p
input	nibble_top.v	/^	input				RESET_L,			\/\/ entrada de reset en bajo que controla los modulos$/;"	p
input	nibble_top.v	/^	input [11:0]		SEL_B,				\/\/ array de selectores del DATA_B$/;"	p
input	nibble_top.v	/^	input [31:0]		DATA_B,				\/\/ Dato B de 32bits$/;"	p
input	tester.v	/^	input [3:0]					DATA_OUT_e		\/\/ monitor de salida del nibble mayor estructural$/;"	p
nibble_top	nibble_top.v	/^module nibble_top($/;"	m
nibble_top_synth	nibble_top_synth.v	/^module nibble_top_synth(DATA_OUT, CLK, RESET_L, DATA_A, DATA_B, SEL_A, SEL_B, SEL_AB);$/;"	m
out_c	checker.v	/^	reg [3:0] 		out_c,out_e; 	$/;"	r
out_e	checker.v	/^	reg [3:0] 		out_c,out_e; 	$/;"	r
reg	checker.v	/^	output reg		check_data_out,		\/\/ salida de 1 bit que indica que ambos datos de data_out son iguales	$/;"	p
reg	nibble_top.v	/^	output reg [3:0]	DATA_OUT,			\/\/ salida general del bloque que contiene el nibble mayor de la seleccion realizada$/;"	p
reg	tester.v	/^	output reg 					CLK,			\/\/ generador del clock$/;"	p
reg	tester.v	/^	output reg 					RESET_L,		\/\/ generador de reset$/;"	p
reg	tester.v	/^	output reg [11:0]			SEL_A,			\/\/ generador del array de selectores del DATA_A$/;"	p
reg	tester.v	/^	output reg [11:0]			SEL_B,			\/\/ generador del array de selectores del DATA_B$/;"	p
reg	tester.v	/^	output reg [31:0]			DATA_A,			\/\/ generador de DATO_A$/;"	p
reg	tester.v	/^	output reg [31:0]			DATA_B,			\/\/ generador de DATO_B$/;"	p
reg	tester.v	/^	output reg [3:0]			SEL_AB,			\/\/ generador del array de selectores para seleccion del DATO_A | DATO_B$/;"	p
tb	tb.v	/^module tb(); \/\/ Testbench$/;"	m
tester	tester.v	/^module tester($/;"	m
